// scanner.cpp generated by reflex 3.3.5 from ./_scaner_reflex.l

#define REFLEX_VERSION "3.3.5"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_YYLTYPE
#undef REFLEX_OPTION_YYSTYPE
#undef REFLEX_OPTION_bison_cc
#undef REFLEX_OPTION_bison_cc_namespace
#undef REFLEX_OPTION_bison_cc_parser
#undef REFLEX_OPTION_bison_complete
#undef REFLEX_OPTION_bison_locations
#undef REFLEX_OPTION_exception
#undef REFLEX_OPTION_fast
#undef REFLEX_OPTION_freespace
#undef REFLEX_OPTION_header_file
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_token_eof
#undef REFLEX_OPTION_token_type
#undef REFLEX_OPTION_unicode

#define REFLEX_OPTION_YYLTYPE             CalcPlusPlus::location
#define REFLEX_OPTION_YYSTYPE             CalcPlusPlus::TParser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  CalcPlusPlus
#define REFLEX_OPTION_bison_cc_parser     TParser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_exception           CalcPlusPlus::TParser::syntax_error(location(), "Unknown token.")
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "scanner.hpp"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               TScanner
#define REFLEX_OPTION_namespace           CalcPlusPlus
#define REFLEX_OPTION_outfile             "scanner.cpp"
#define REFLEX_OPTION_token_eof           CalcPlusPlus::TParser::symbol_type(0, location())
#define REFLEX_OPTION_token_type          CalcPlusPlus::TParser::symbol_type
#define REFLEX_OPTION_unicode             true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 4 "./_scaner_reflex.l"

    #include <project-config.hpp>
    //
    // Подключаем заголовочные файлы парсера
    //
    #include "parser.hpp"
    #include "location.hpp"
    #include "fw_base.hpp"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS INCLUDE                                                       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "scanner.hpp"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "./_scaner_reflex.l"
//
// Код будет добавлен в заголовочный файл сканера (hpp)
//
#line 14 "./_scaner_reflex.l"
//
// Код будет помещён в начало cpp файла сканера
//

    //
    // Отключаем предупреждение для WINDOWS
    //
#ifdef WINDOWS
    #pragma warning(disable:4102)
#endif

#line 26 "./_scaner_reflex.l"
//
// Опции сканера
//
// Игнорируем пробелы в регулярных выражениях (для удобства)
#line 31 "./_scaner_reflex.l"
// Оптимизация сканера (таблица состояний помещается в код сканера)
#line 33 "./_scaner_reflex.l"
// Поддержка юникода
#line 35 "./_scaner_reflex.l"
// Пространство имён сканера (такое же как у парсера)
#line 37 "./_scaner_reflex.l"
// Имя класса сканера
#line 39 "./_scaner_reflex.l"
// Имя файла с кодом сканера (cpp)
#line 41 "./_scaner_reflex.l"
// Имя заголовочного файла (hpp)
#line 43 "./_scaner_reflex.l"
// Обработка исключений
#line 46 "./_scaner_reflex.l"
//
// Опции для совместимости с BISON
//
#line 55 "./_scaner_reflex.l"
//
// Класс сканера
//
#line 254 "./_scaner_reflex.l"
// %option ctorarg="const std::vector<std::pair<std::string, std::string>>& include_list" /* Используется в Сервере ИВК */
// %option ctorinit="_include_list(include_list), depth(0)" /* Используется в Сервере ИВК */

#line 257 "./_scaner_reflex.l"
//
// Регулярные выражения
//
#line 270 "./_scaner_reflex.l"
//
// Правила сканера
//

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace CalcPlusPlus {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace CalcPlusPlus

CalcPlusPlus::TParser::symbol_type CalcPlusPlus::TScanner::lex(void)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
#line 304 "./_scaner_reflex.l"
{ if (end_of_file()) return TParser::make_EOF(location()); } // Конец входного потока символов

            }
            else
            {
              throw CalcPlusPlus::TParser::syntax_error(location(), "Unknown token.");
            }
            break;
          case 1: // rule ./_scaner_reflex.l:275: [[:space:]]+ :
#line 275 "./_scaner_reflex.l"
{} // Игнорируем пробельные символы

            break;
          case 2: // rule ./_scaner_reflex.l:277: "//".*\n :
#line 277 "./_scaner_reflex.l"
{} // Игнорируем одностроковые комментарии
            break;
          case 3: // rule ./_scaner_reflex.l:278: "/*"(.|\n)*?"*/" :
#line 278 "./_scaner_reflex.l"
{} // Игнорируем мультистроковые комментарии

            break;
          case 4: // rule ./_scaner_reflex.l:280: {include} :
#line 280 "./_scaner_reflex.l"
{ make_include(); }
            break;
          case 5: // rule ./_scaner_reflex.l:281: {double} :
#line 281 "./_scaner_reflex.l"
{ return TParser::make_NUMBER(Framework::String::TStringConverter::FromString(text(), std::numeric_limits<double>::quiet_NaN()) , location()); }
            break;
          case 6: // rule ./_scaner_reflex.l:282: {identifier} :
#line 282 "./_scaner_reflex.l"
{ return KeywordIdentifier(); }
            break;
          case 7: // rule ./_scaner_reflex.l:283: \[ .+? \] :
#line 283 "./_scaner_reflex.l"
{
                                    std::string _identifier = AUTO_ENCODING(decltype(_identifier), str());
                                    _identifier.erase(0, 1).erase(std::size(_identifier) - 1, 1);
                                    return TParser::make_IDENTIFIER(_identifier, location());
                                }

            break;
          case 8: // rule ./_scaner_reflex.l:289: [+\-*/;()><=#{},] :
#line 289 "./_scaner_reflex.l"
{ return TParser::symbol_type(chr(), location()); }

            break;
          case 9: // rule ./_scaner_reflex.l:291: "==" :
#line 291 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_EQ, location()); }
            break;
          case 10: // rule ./_scaner_reflex.l:292: "!=" :
#line 292 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_NE, location()); }
            break;
          case 11: // rule ./_scaner_reflex.l:293: "<=" :
#line 293 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_LE, location()); }
            break;
          case 12: // rule ./_scaner_reflex.l:294: ">=" :
#line 294 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_GE, location()); }
            break;
          case 13: // rule ./_scaner_reflex.l:295: "&&" :
#line 295 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_AND, location()); }
            break;
          case 14: // rule ./_scaner_reflex.l:296: "||" :
#line 296 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_OR, location()); }
            break;
          case 15: // rule ./_scaner_reflex.l:297: "++" :
#line 297 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_PP, location()); }
            break;
          case 16: // rule ./_scaner_reflex.l:298: "--" :
#line 298 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_NN, location()); }
            break;
          case 17: // rule ./_scaner_reflex.l:299: "+=" :
#line 299 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_PA, location()); }
            break;
          case 18: // rule ./_scaner_reflex.l:300: "-=" :
#line 300 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_NA, location()); }
            break;
          case 19: // rule ./_scaner_reflex.l:301: "*=" :
#line 301 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_MA, location()); }
            break;
          case 20: // rule ./_scaner_reflex.l:302: "/=" :
#line 302 "./_scaner_reflex.l"
{ return TParser::symbol_type(TParser::token::TOKEN_DA, location()); }

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace CalcPlusPlus {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == 209) goto S47;
  if (c1 == 208) goto S44;
  if (c1 == '|') goto S68;
  if ('{' <= c1 && c1 <= '}') goto S53;
  if ('a' <= c1 && c1 <= 'z') goto S36;
  if (c1 == '_') goto S36;
  if (c1 == '[') goto S50;
  if ('A' <= c1 && c1 <= 'Z') goto S36;
  if (c1 == '>') goto S63;
  if (c1 == '=') goto S55;
  if (c1 == '<') goto S60;
  if (c1 == ';') goto S53;
  if ('0' <= c1 && c1 <= '9') goto S91;
  if (c1 == '/') goto S25;
  if (c1 == '-') goto S74;
  if (c1 == '+') goto S70;
  if (c1 == '*') goto S78;
  if ('(' <= c1 && c1 <= ',') goto S53;
  if (c1 == '&') goto S66;
  if (c1 == '#') goto S30;
  if (c1 == '!') goto S58;
  if (c1 == ' ') goto S85;
  if ('\n' <= c1 && c1 <= '\r') goto S81;
  if (c1 == '\t') goto S85;
  return m.FSM_HALT(c1);

S25:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S101;
  if (c1 == '/') goto S96;
  if (c1 == '*') goto S98;
  return m.FSM_HALT(c1);

S30:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S103;
  if (c1 == 'I') goto S103;
  if (c1 == ' ') goto S106;
  if (c1 == '\t') goto S106;
  return m.FSM_HALT(c1);

S36:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 209) goto S114;
  if (c1 == 208) goto S111;
  if ('a' <= c1 && c1 <= 'z') goto S36;
  if (c1 == '_') goto S36;
  if ('A' <= c1 && c1 <= 'Z') goto S36;
  if ('0' <= c1 && c1 <= '9') goto S36;
  return m.FSM_HALT(c1);

S44:
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S36;
  if (c1 == 129) goto S36;
  return m.FSM_HALT(c1);

S47:
  c1 = m.FSM_CHAR();
  if (c1 == 145) goto S36;
  if (128 <= c1 && c1 <= 143) goto S36;
  return m.FSM_HALT(c1);

S50:
  c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S117;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S117;
  return m.FSM_HALT(c1);

S53:
  m.FSM_TAKE(8);
  return m.FSM_HALT();

S55:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S121;
  return m.FSM_HALT(c1);

S58:
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S123;
  return m.FSM_HALT(c1);

S60:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S125;
  return m.FSM_HALT(c1);

S63:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S127;
  return m.FSM_HALT(c1);

S66:
  c1 = m.FSM_CHAR();
  if (c1 == '&') goto S129;
  return m.FSM_HALT(c1);

S68:
  c1 = m.FSM_CHAR();
  if (c1 == '|') goto S131;
  return m.FSM_HALT(c1);

S70:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S135;
  if (c1 == '+') goto S133;
  return m.FSM_HALT(c1);

S74:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S139;
  if (c1 == '-') goto S137;
  return m.FSM_HALT(c1);

S78:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S141;
  return m.FSM_HALT(c1);

S81:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S81;
  if ('\t' <= c1 && c1 <= '\r') goto S81;
  return m.FSM_HALT(c1);

S85:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (c1 == '#') goto S106;
  if (c1 == ' ') goto S85;
  if ('\n' <= c1 && c1 <= '\r') goto S81;
  if (c1 == '\t') goto S85;
  return m.FSM_HALT(c1);

S91:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S91;
  if (c1 == '.') goto S143;
  if (c1 == ',') goto S143;
  return m.FSM_HALT(c1);

S96:
  c1 = m.FSM_CHAR();
  if (c1 == '\n') goto S145;
  if (0 <= c1) goto S96;
  return m.FSM_HALT(c1);

S98:
  c1 = m.FSM_CHAR();
  if (c1 == '*') goto S147;
  if (c1 == '\n') goto S156;
  if (0 <= c1) goto S152;
  return m.FSM_HALT(c1);

S101:
  m.FSM_TAKE(20);
  return m.FSM_HALT();

S103:
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S159;
  if (c1 == 'N') goto S159;
  return m.FSM_HALT(c1);

S106:
  c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S103;
  if (c1 == 'I') goto S103;
  if (c1 == ' ') goto S106;
  if (c1 == '\t') goto S106;
  return m.FSM_HALT(c1);

S111:
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S36;
  if (c1 == 129) goto S36;
  return m.FSM_HALT(c1);

S114:
  c1 = m.FSM_CHAR();
  if (c1 == 145) goto S36;
  if (128 <= c1 && c1 <= 143) goto S36;
  return m.FSM_HALT(c1);

S117:
  c1 = m.FSM_CHAR();
  if (c1 == ']') goto S162;
  if ('\v' <= c1) goto S164;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S164;
  return m.FSM_HALT(c1);

S121:
  m.FSM_TAKE(9);
  return m.FSM_HALT();

S123:
  m.FSM_TAKE(10);
  return m.FSM_HALT();

S125:
  m.FSM_TAKE(11);
  return m.FSM_HALT();

S127:
  m.FSM_TAKE(12);
  return m.FSM_HALT();

S129:
  m.FSM_TAKE(13);
  return m.FSM_HALT();

S131:
  m.FSM_TAKE(14);
  return m.FSM_HALT();

S133:
  m.FSM_TAKE(15);
  return m.FSM_HALT();

S135:
  m.FSM_TAKE(17);
  return m.FSM_HALT();

S137:
  m.FSM_TAKE(16);
  return m.FSM_HALT();

S139:
  m.FSM_TAKE(18);
  return m.FSM_HALT();

S141:
  m.FSM_TAKE(19);
  return m.FSM_HALT();

S143:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S168;
  return m.FSM_HALT(c1);

S145:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S147:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  if (c1 == '/') goto S173;
  if (c1 == '*') goto S175;
  if (c1 == '\n') goto S156;
  if (0 <= c1) goto S152;
  return m.FSM_HALT(c1);

S152:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  if (c1 == '*') goto S175;
  if (c1 == '\n') goto S156;
  if (0 <= c1) goto S152;
  return m.FSM_HALT(c1);

S156:
  c1 = m.FSM_CHAR();
  if (c1 == '*') goto S175;
  if (c1 == '\n') goto S156;
  if (0 <= c1) goto S152;
  return m.FSM_HALT(c1);

S159:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S184;
  if (c1 == 'C') goto S184;
  return m.FSM_HALT(c1);

S162:
  m.FSM_TAKE(7);
  return m.FSM_HALT();

S164:
  c1 = m.FSM_CHAR();
  if (c1 == ']') goto S187;
  if ('\v' <= c1) goto S164;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S164;
  return m.FSM_HALT(c1);

S168:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S189;
  if (c1 == 'E') goto S189;
  if ('0' <= c1 && c1 <= '9') goto S168;
  return m.FSM_HALT(c1);

S173:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S175:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  if (c1 == '/') goto S193;
  if (c1 == '*') goto S175;
  if (c1 == '\n') goto S156;
  if (0 <= c1) goto S152;
  return m.FSM_HALT(c1);

S180:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  if (c1 == '*') goto S147;
  if (c1 == '\n') goto S156;
  if (0 <= c1) goto S152;
  return m.FSM_HALT(c1);

S184:
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S195;
  if (c1 == 'L') goto S195;
  return m.FSM_HALT(c1);

S187:
  m.FSM_TAKE(7);
  return m.FSM_HALT();

S189:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S200;
  if (c1 == '-') goto S198;
  if (c1 == '+') goto S198;
  return m.FSM_HALT(c1);

S193:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S195:
  c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S203;
  if (c1 == 'U') goto S203;
  return m.FSM_HALT(c1);

S198:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S200;
  return m.FSM_HALT(c1);

S200:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S200;
  return m.FSM_HALT(c1);

S203:
  c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S206;
  if (c1 == 'D') goto S206;
  return m.FSM_HALT(c1);

S206:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S209;
  if (c1 == 'E') goto S209;
  return m.FSM_HALT(c1);

S209:
  c1 = m.FSM_CHAR();
  if (c1 == '"') goto S213;
  if (c1 == ' ') goto S209;
  if (c1 == '\t') goto S209;
  return m.FSM_HALT(c1);

S213:
  c1 = m.FSM_CHAR();
  if (c1 == '"') goto S217;
  if ('\v' <= c1) goto S221;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S221;
  return m.FSM_HALT(c1);

S217:
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(4, c1);
    m.FSM_TAIL(0);
  }
  if (c1 == 'h') goto S225;
  return m.FSM_HALT(c1);

S221:
  c1 = m.FSM_CHAR();
  if (c1 == '"') goto S231;
  if ('\v' <= c1) goto S221;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S221;
  return m.FSM_HALT(c1);

S225:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(4, c1);
    m.FSM_TAIL(0);
  }
  if (c1 == 'h') goto S225;
  return m.FSM_HALT(c1);

S228:
  m.FSM_TAKE(4);
  m.FSM_TAIL(0);
  return m.FSM_HALT();

S231:
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(4);
    m.FSM_TAIL(0);
  }
  return m.FSM_HALT();
}

} // namespace CalcPlusPlus

